# -*- coding: utf-8 -*-
"""Random  + Hackerrank Probelms.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lrWpLnBy5ro9GuXEUNkp1p4A5_HDyJ10
"""

#Decimal to Binary without any built in methods

def isDecimal(num):
    try:
        int(num)
        return True
    except ValueError:
        return False

def decimal_to_binary():
    """Repeatedly asks for a valid decimal number and converts it to binary."""
    while True:  # Loop until a valid input is given
        num = input("Enter a Decimal Number: ")

        if isDecimal(num):  # Check if input is a valid integer
            decimal_num = int(num)
            if decimal_num == 0:
                binary_num = '0'
            else:
                binary_num = ''
                temp_num = decimal_num
                while temp_num > 0:
                    remainder = temp_num % 2
                    binary_num = str(remainder) + binary_num
                    temp_num = temp_num // 2

            print(f"Binary equivalent: {binary_num}")
            break  # Exit loop after successful conversion
        else:
            print("Invalid input! Please enter a valid decimal number.")
decimal_to_binary()

import heapq

nums = [1, 3, 4, 2, 5, 8]

sorted_list = [heapq.heappop(nums) for _ in range(len(nums))]
print("Sorted by popping:", sorted_list)

#Hacker Rank CLosest Numbers in a given array

def closestNumbers(arr):

    arr.sort()
    gaps = [arr[i + 1] - arr[i] for i in range(len(arr) - 1)]

    min_gap = min(gaps)

    output = [i for i in range(len(arr) - 1) if gaps[i] == min_gap for i in (arr[i], arr[i + 1])]

    return output

closestNumbers([1, 3, 4, 2, 5, 8])

#find smallest postive number

def findSmallestMissingPositive(orderNumbers):
    # Write your code here
    if len(orderNumbers) == 0:
        return 1
    max_value = 10**18

    for i in range(1, max_value):
        if i not in orderNumbers:
            return i


findSmallestMissingPositive([1, -1, 3, 5, 6, -2, 2])

#Count Elements Greater Than Previous Average

def countResponseTimeRegressions(responseTimes):
    output = 0
    if len(responseTimes) < 1:
        return output

    running_sum = responseTimes[0]

    for i in range(1, len(responseTimes)):
        avg = running_sum / i
        if responseTimes[i] > avg:
            output += 1
        running_sum += responseTimes[i]  # <-- fixed here

    return output

countResponseTimeRegressions([100, 200, 150,300])

#Alphabetic Palindrome with Regex
import re

def isAlphabeticPalindrome(code):
    # Write your code here
    cleaned_code = re.sub(r"[^a-zA-Z]", "", code)

    cleaned_code = cleaned_code.lower()

    l = len(cleaned_code)

    if l <= 1:
        return "1"

    for i in range(l // 2):
        if cleaned_code[i] != cleaned_code[l - 1 - i]:
            return "0"

    return "1"

isAlphabeticPalindrome("A man, a plan, a canal: Panama")

#Non-Identical String ROTATION
def isNonTrivialRotation(s1, s2):
    # Write your code here

    if s1 == s2:
        return "0"

    if len(s2) != len(s1):
        return "0"

    if s2 not in (s1 + s1):
        return "0"

    return "1"

print(isNonTrivialRotation("abcd", "cdab"))
print(isNonTrivialRotation("abcd", "cdba"))
print(isNonTrivialRotation("abcd", "abcd"))
print(isNonTrivialRotation("abcd", "cdba"))

str = "aeiou"
arr = list(str)
str_again = "".join(arr)
print(str_again)
print(str)

def factors(n):
  facts = []
  for i in range(1, int(n ** (1/2)) + 1):
    if n % i == 0:
      facts.append(i)
      facts.append(int(n/i))

  facts.sort()
  return facts

factors(20)

#string palindrome
import re

def isPalindrome(str):
  cleaned = re.sub(r"[^a-zA-Z]", "", str)

  l = len(cleaned)

  for i in range(l // 2):
    if cleaned[i] != cleaned[l - 1 - i]:
      return False
  return True


isPalindrome("")

def NumericPalindrome(n):
  og = n
  if n < 0:
    n = abs(n)

  reverse_num = 0

  while n > 0:
    digit = n % 10
    reverse_num = reverse_num * 10 + digit
    n = n // 10

  if og < 0:
    reverse_num = reverse_num * -1

  return False

NumericPalindrome(-1234321)

def universalPalindrome(s):
  s = __builtins__.str(s)
  return s == s[:: -1]

universalPalindrome(-123456789)

#Binary Search
def binarySearch(nums, target):
  l, r = 0, len(nums) - 1

  while l <= r:

    mid = l + (r - l) // 2 # (r + l) // 2 - getting the mid directly as r = len(nums) - 1

    if target > nums[mid]:
      l = mid + 1

    elif target < nums[mid]:
      r = mid - 1

    else:
      result = mid
      break

  return result


binarySearch([2, 4, 6, 8, 10, 12, 14, 16], 16)
binarySearch([2], 2)
binarySearch([], 2)
binarySearch([2, 2, 4, 6, 8, 10, 12, 14, 16, 16], 2)

from typing import List

#Leetcode - First and Last position of an element
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        first = self.binarySearch(nums, target, True)
        last = self.binarySearch(nums, target, False)
        return [first, last]

    def binarySearch(self, nums: List[int], target: int, leftSearch: bool) -> int:
        l, r = 0, len(nums) - 1
        index = -1

        while l <= r:
            mid = l + (r - l) // 2

            if target > nums[mid]:
                l = mid + 1
            elif target < nums[mid]:
                r = mid - 1
            else:
                index = mid
                if leftSearch:
                    r = mid - 1
                else:
                    l = mid + 1
        return index

BS = Solution()
BS.searchRange([5,7,7,8,8,10], 8)
BS.searchRange([5,5,10,45,19], 6)