# -*- coding: utf-8 -*-
"""Strives - Patterns.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CoDWAw__g63ONn2XMp6MQ857AvjvEgET
"""

class Solution:
    def studentGrade(self, marks):
        if marks >= 90:
            print("Grade A")
        elif marks >= 70:
            print("Grade B")
        elif marks >= 50:
            print("Grade C")
        elif marks >= 35:
            print("Grade D")
        else:
            print("Fail")

marks = int(input("marks = "))

solution = Solution()

solution.studentGrade(marks)

#Switch Case
class Solution:
    def whichWeekDay(self, day):
        match day:
            case 1:
                print("Monday")
            case 2:
                print("Tuesday")
            case 3:
                print("Wednesday")
            case 4:
                print("Thursday")
            case 5:
                print("Friday")
            case 6:
                print('Saturday')
            case 7:
                print('Sunday')
            case _:
                print('Invalid day')
s = Solution()
day = int(input("day = "))
s.whichWeekDay(day)

#manual reverse array
class reverse_array:
  def solution(self, arr):
    start = 0
    end = len(arr) -1
    while start < end:
      arr[start], arr[end] = arr[end], arr[start]
      start +=1
      end -=1
    return arr

reverse = reverse_array()
array = [1,2,3,4,5,6]
print(reverse.solution(array))

#fizzbuzz algo
class fizz_buzz:
  def solution(self,input):
    if input %3 == 0 and input %5 == 0:
      return 'Fizzbuzz'
    elif input %3 == 0:
      return 'Fizz'
    elif input %5 == 0:
      return 'Buzz'
    else:
      return input

FizzBuzz = fizz_buzz()
print(FizzBuzz.solution(15))

#Patters (n x n)
class pattern1:
  def solution(self):
    for i in range(4):
      for j in range(4):
        print('*', end = " ")
      print()

p1 = pattern1()
p1.solution()

#Pattern 2
class pattern2:
  def solution(self):
    for i in range(5):
      for j in range(i + 1):
        print("*", end = " ")
      print()

p2 = pattern2()
p2.solution()

#Pattern 3
class pattern3:
  def solution(self):
    for i in range(5):
      for j in range(1, i + 2):
        print(j, end = " ")
      print()

p3 = pattern3()
p3.solution()



#Pattern 4
class pattern4:
  def solution(self):
    n = int(input("Size of Matrix: "))
    for i in range(n):
      for j in range(n, i, -1):
        print('*', end = " ")
      print()

p4 = pattern4()
p4.solution()



#Pattern 4
class pattern4:
  def solution(self):
    for i in range(5):
      for j in range(5 - i): #range(5, i, -1)
        print('*', end = " ")
      print()

p4 = pattern4()
p4.solution()

#Pattern 5
class pattern5:
  def solution(self):
    for i in range(5):
      for j in range(1, (5+1 - i)):
        print(j, end = " ")
      print()

p5 = pattern5()
p5.solution()

#Pattern 6
class pattern6:
  def solution(self):
    for i in range(5):
      for j in range(5, i, -1):
        print(j, end = " ")
      print()

p6 = pattern6()
p6.solution()

class pattern7:
  def solution(self):
    for i in range(5):
      #spaces
      for j in range(5 - i):
        print(' ', end = " ")
      #stars
      for j in range(i + 1):
        print('*', end = " ")
      print()

p7 = pattern7()
p7.solution()

#pattern 8
class pattern8:
  def solution(self):
    for i in range(5):
      #spaces
      for j in range(5 - i):
        print(' ', end = " ")
      #numbers
      for j in range(1, i + 2):
        print(j, end = " ")
      print()

p8 = pattern8()
p8.solution()

#pattern 9
class pattern9:
  def solution(self):
    for i in range(5):
      #spaces
      for j in range(5 - i):
        print(' ', end = " ")
      for j in range(i + 1):
        print(i+1, end = " ")
      print()

p9 = pattern9()
p9.solution()

#pattern10
class pattern10:
  def solution(self):
    for i in range(5):
      #spaces
      for j in range(5 - i):
        print(' ', end = ' ')
      for j in range(i + 1, 0, -1):
        print(j, end = ' ')
      print()

p10 = pattern10()
p10.solution()

#pattern11
class pattern11:
  def solution(self):
    n = int(input('rows ='))

    for i in range(n):
      #spaces
      for j in range(n - i - 1):
        print(' ', end = ' ')
      #numbers
      for j in range(i * 2 + 1):
        print('*', end = ' ')
      #spaces
      for j in range(n - i - 1):
        print(' ', end = ' ')

      print()

p11 = pattern11()
p11.solution()

#pattern11
class pattern11:
  def solution(self):
    n = int(input('rows ='))

    for i in range(n):
      #spaces
      for j in range(n - i - 1):
        print(' ', end = ' ')
      #numbers
      for j in range(n - i, n + i + 1):
        print(j, end = ' ')
      #spaces
      for j in range(n - i - 1):
        print(' ', end = ' ')

      print()

p11 = pattern11()
p11.solution()

#pattern12
class pattern12:
  def solution(self):
    n = int(input('rows ='))

    for i in range(n):
      #spaces
      for j in range(i):
        print(' ', end = ' ')
      #numbers
      for j in range(2*n - 2*i -1, 0, -1):
        print('*', end = ' ')
      #spaces
      for j in range(i):
        print(' ', end = ' ')

      print()

p12 = pattern12()
p12.solution()

#pattern13
class pattern13:
  def solution(self):
    n = int(input('rows ='))

    for i in range(n):
      #spaces
      for j in range(i):
        print(' ', end = ' ')
      #numbers
      for j in range(i + 1, 2 * n - i):
        print(j, end = ' ')


      print()

p13 = pattern13()
p13.solution()

#pattern14
class pattern14:
  def solution(self):
    n = int(input('rows ='))
    #upper pyramid
    for i in range(n):
      spaces = '  ' * (n - i -1)
      stars = '* ' * (2 * i + 1)
      print(spaces + stars)

    #lower pyramid(inverted)
    for i in range(n):
      spaces = '  ' * i
      starts = '* ' * (2 * (n - i) - 1)
      print(spaces + starts)


p14 = pattern14()
p14.solution()

#pattern15
class pattern15:
  def solution(self):
    n = int(input('rows ='))

    for i in range(n):
      spaces = '* ' * (i + 1)
      print(spaces)
    for i in range(n - 1):
      spaces = '* ' * (n - i - 1)
      print(spaces)


p15 = pattern15()
p15.solution()

#Pattern 16
class pattern16:

  def solution(self):
    n = int(input('rows ='))

    for i in range(n):
      if i % 2 == 0:
        start = 1
      else:
        start = 0
      for j in range(i + 1):
        print(start, end = " ")
        start = 1 - start
      print()



p16 = pattern16()
p16.solution()

#Pattern 18
class pattern18:

  def solution(self):
    n = int(input('rows ='))

    for i in range(n):
      for j in range(1, i + 2):
        print(j, end = ' ')
      for j in range(2 * n - 2 * i - 2):
        print(' ', end = ' ')
      for j in range(i + 1, 0, -1):
        print(j, end = ' ')

      print()


p18 = pattern18()
p18.solution()

#Pattern 19
class pattern19:

  def solution(self):
    n = int(input('rows ='))

    start = 1
    for i in range(n):
      for j in range(i + 1):
        print(start, end = ' ')
        start = start + 1
      print()

p19 = pattern19()
p19.solution()

#Pattern20
class pattern20:

  def solution(self):
    n = int(input('rows ='))

    for i in range(n):
      for j in range(i + 1):
        character = chr(ord('A') + j)
        print(character, end = ' ')
      print()

    for i in range(n):
      letter = [chr(ord('A') + j) for j in range(i + 1)]
      print(' '.join(letter))


p20 = pattern20()
p20.solution()

#Formatting a String

def FormatString(s):
  newString = ''
  for ch in s:
    if ch != ' ' and ch != '-':
      newString += ch

  formatted_string = ''
  for i in range(len(newString)):
    formatted_string += newString[i]
    if (i + 1) % 3 == 0 and i + 1 != len(newString):
      formatted_string += ' '

  print(f'{formatted_string};')

FormatString('AA-44 BB 55CD 83FG')

class pattern20:
  def solution(self):
    n = int(input('number of rows: '))

    for i in range(n):
      for j in range(i+1):
        print(chr(ord('A') + i), end = ' ')
      print()

p20 = pattern20();
p20.solution()

#BoilerPlate
class pattern:
  def solution(self, n = None):
    if n == None:
       n = int(input('Enter the number of rows: '))



p = pattern();
p.solution()

class pattern21:
  def solution(self):
    n = int(input('number of rows: '))

    for i in range(n):
      for j in range(n - i - 1):
        print(' ', end = ' ')
      for j in range(i + 1):
        char = chr(ord('A') + j)
        print(char, end = ' ')
      for j in range(i - 1, - 1, -1):
        char = chr(ord('A') + j)
        print(char, end = ' ')

      print()

p21 = pattern21();
p21.solution()

#Pattern 21 using List Comprehension
class pattern21_optimized:
    def solution(self, n):
        for i in range(n):
          spaces = '  ' * (n - i - 1)
          letters = [chr(ord('A') + j) for j in range(i + 1)]
          pattern = letters + letters[-2::-1]
          row = spaces + ' '.join(pattern)
          print(row)


# Test
n = 4

p_opt = pattern21_optimized()
p_opt.solution(n)

#Pattern 22
class pattern22:
  def solution(self, n = None):
    if n == None:
       n = int(input('Enter the number of rows: '))

    for i in range(n):
      letters = [chr(ord('A') + j) for j in range (n - i - 1, n)]
      print(letters)

      #print(' '.join(letters))

p22 = pattern22();
p22.solution()

#Pattern23
class pattern23:
  def solution(self, n = None):
    if n == None:
       n = int(input('Enter the number of rows: '))
    #UpperHalf
    for i in range(n):
      letters = ['*' for j in range(n - i)]
      spaces = [' ' for j in range(i)]
      half_row = letters + spaces

      upper_rows = half_row + half_row[::-1]

      print(' '.join(upper_rows))

    #LowerHalf
    for i in range(n):
      letters = ['*' for j in range(i + 1)]
      spaces = [' ' for j in range(n - i - 1)]
      half_row = letters + spaces

      lower_rows = half_row + half_row[::-1];

      print(' '.join(lower_rows))

p23 = pattern23();
p23.solution()

#Performance Test - Pattern 23
import time
import timeit
import matplotlib.pyplot as plt
import numpy as np

class Pattern23Original:
    def solution(self, n):
        #UpperHalf
        for i in range(n):
            letters = ['*' for j in range(n - i)]
            spaces = [' ' for j in range(i)]
            half_row = letters + spaces
            upper_rows = half_row + half_row[::-1]
            # print(' '.join(upper_rows))

        #LowerHalf
        for i in range(n):
            letters = ['*' for j in range(i + 1)]
            spaces = [' ' for j in range(n - i - 1)]
            half_row = letters + spaces
            lower_rows = half_row + half_row[::-1]
            # print(' '.join(lower_rows))

class Pattern23Optimized:
    def solution(self, n):
        for i in range(2 * n):
            # Determine stars and spaces based on position
            if i < n:
                stars, spaces = n - i, i
            else:
                stars, spaces = i - n + 1, 2 * n - i - 1

            # Create half pattern and mirror it
            half = '*' * stars + ' ' * spaces
            result = ' '.join(half + half[::-1])
            # print(result)

def time_function(func, n, repetitions=100):
    """Time a function with given input"""
    def wrapper():
        return func(n)

    # Warm-up
    for _ in range(5):
        wrapper()

    # Measure time
    total_time = 0
    for _ in range(repetitions):
        start_time = time.perf_counter()
        wrapper()
        end_time = time.perf_counter()
        total_time += (end_time - start_time)

    return total_time / repetitions

def benchmark_single_value():
    """Benchmark for a single value of n"""
    n = 100
    original = Pattern23Original()
    optimized = Pattern23Optimized()

    print(f"Benchmarking for n = {n}")
    print("=" * 40)

    # Time original method
    time_original = timeit.timeit(lambda: original.solution(n), number=100)
    print(f"Original method: {time_original:.6f} seconds (100 runs)")

    # Time optimized method
    time_optimized = timeit.timeit(lambda: optimized.solution(n), number=100)
    print(f"Optimized method: {time_optimized:.6f} seconds (100 runs)")

    # Calculate speedup
    speedup = time_original / time_optimized
    print(f"Speedup: {speedup:.2f}x")
    print(f"Optimized is {speedup:.1f} times faster")

def benchmark_range():
    """Benchmark across a range of n values"""
    n_values = [10, 20, 50, 100, 200, 500]
    original_times = []
    optimized_times = []
    speedups = []

    original_obj = Pattern23Original()
    optimized_obj = Pattern23Optimized()

    print("Benchmarking across different n values:")
    print("n\tOriginal\tOptimized\tSpeedup")
    print("-" * 50)

    for n in n_values:
        # Time original method
        time_orig = timeit.timeit(lambda: original_obj.solution(n), number=50)
        original_times.append(time_orig)

        # Time optimized method
        time_opt = timeit.timeit(lambda: optimized_obj.solution(n), number=50)
        optimized_times.append(time_opt)

        speedup = time_orig / time_opt
        speedups.append(speedup)

        print(f"{n}\t{time_orig:.6f}\t{time_opt:.6f}\t{speedup:.2f}x")

    return n_values, original_times, optimized_times, speedups

def plot_results(n_values, original_times, optimized_times, speedups):
    """Plot the benchmarking results"""
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))

    # Plot execution times
    ax1.plot(n_values, original_times, 'ro-', label='Original Method', linewidth=2, markersize=8)
    ax1.plot(n_values, optimized_times, 'bo-', label='Optimized Method', linewidth=2, markersize=8)
    ax1.set_xlabel('n (pattern size)')
    ax1.set_ylabel('Execution Time (seconds)')
    ax1.set_title('Execution Time Comparison')
    ax1.legend()
    ax1.grid(True, alpha=0.3)

    # Plot speedup
    ax2.plot(n_values, speedups, 'go-', linewidth=2, markersize=8)
    ax2.set_xlabel('n (pattern size)')
    ax2.set_ylabel('Speedup (Original/Optimized)')
    ax2.set_title('Performance Speedup')
    ax2.grid(True, alpha=0.3)

    # Add speedup values on the plot
    for i, (n, speedup) in enumerate(zip(n_values, speedups)):
        ax2.annotate(f'{speedup:.1f}x', (n, speedup), textcoords="offset points",
                    xytext=(0,10), ha='center')

    plt.tight_layout()
    plt.show()

def memory_usage_test():
    """Test memory usage patterns"""
    import tracemalloc
    import gc

    n = 200
    print(f"\nMemory Usage Test for n = {n}")
    print("=" * 40)

    # Test original method memory
    gc.collect()
    tracemalloc.start()
    original = Pattern23Original()
    original.solution(n)
    current, peak = tracemalloc.get_traced_memory()
    tracemalloc.stop()
    print(f"Original method - Peak memory: {peak / 1024:.2f} KB")

    # Test optimized method memory
    gc.collect()
    tracemalloc.start()
    optimized = Pattern23Optimized()
    optimized.solution(n)
    current, peak = tracemalloc.get_traced_memory()
    tracemalloc.stop()
    print(f"Optimized method - Peak memory: {peak / 1024:.2f} KB")

def detailed_performance_analysis():
    """Detailed performance analysis with statistical measures"""
    n = 100
    repetitions = 1000

    original_obj = Pattern23Original()
    optimized_obj = Pattern23Optimized()

    print(f"\nDetailed Performance Analysis (n={n}, {repetitions} repetitions)")
    print("=" * 60)

    # Measure original method
    original_times = []
    for _ in range(repetitions):
        start = time.perf_counter()
        original_obj.solution(n)
        end = time.perf_counter()
        original_times.append(end - start)

    # Measure optimized method
    optimized_times = []
    for _ in range(repetitions):
        start = time.perf_counter()
        optimized_obj.solution(n)
        end = time.perf_counter()
        optimized_times.append(end - start)

    # Calculate statistics
    def calculate_stats(times):
        return {
            'mean': np.mean(times),
            'std': np.std(times),
            'min': np.min(times),
            'max': np.max(times),
            'p95': np.percentile(times, 95)
        }

    orig_stats = calculate_stats(original_times)
    opt_stats = calculate_stats(optimized_times)

    print("Original Method Statistics:")
    print(f"  Mean: {orig_stats['mean']*1000:.3f} ms")
    print(f"  Std: {orig_stats['std']*1000:.3f} ms")
    print(f"  Min: {orig_stats['min']*1000:.3f} ms")
    print(f"  Max: {orig_stats['max']*1000:.3f} ms")
    print(f"  95th %ile: {orig_stats['p95']*1000:.3f} ms")

    print("\nOptimized Method Statistics:")
    print(f"  Mean: {opt_stats['mean']*1000:.3f} ms")
    print(f"  Std: {opt_stats['std']*1000:.3f} ms")
    print(f"  Min: {opt_stats['min']*1000:.3f} ms")
    print(f"  Max: {opt_stats['max']*1000:.3f} ms")
    print(f"  95th %ile: {opt_stats['p95']*1000:.3f} ms")

    speedup = orig_stats['mean'] / opt_stats['mean']
    print(f"\nAverage Speedup: {speedup:.2f}x")

# Run all tests
if __name__ == "__main__":
    print("Performance Comparison: Pattern Printing Methods")
    print("=" * 50)

    # Single value benchmark
    benchmark_single_value()

    # Range benchmark
    n_vals, orig_times, opt_times, speedups = benchmark_range()

    # Memory test
    memory_usage_test()

    # Detailed analysis
    detailed_performance_analysis()

    # Plot results
    plot_results(n_vals, orig_times, opt_times, speedups)

#Pattern24
class pattern24:
  def solution(self, n = None):
    if n == None:
       n = int(input('Enter the number of rows: '))

    #Upper Half
    for i in range(n):
      letters = ['* ' for j in range(i + 1)]
      spaces = ['  ' for j in range(n - i - 1)]
      half_row = letters + spaces

      upper_rows = half_row + half_row[::-1]

      print(''.join(upper_rows))

    #Lower_Half
    for i in range(n):
      letters = ['* ' for j in range(n - i - 1)]
      spaces = ['  ' for j in range(i + 1)]
      half_row = letters + spaces

      lower_rows = half_row + half_row[::-1]

      print(''.join(lower_rows))


p24 = pattern24();
p24.solution()

#Pattern25
class pattern25:
  def solution(self, n = None):
    if n == None:
       n = int(input('Enter the number of rows: '))

    for i in range(n):
        for j in range(n):
          if i == 0 or i == n - 1 or j == 0 or j == n - 1:
            print('* ', end = '')
          else:
            print('  ', end = '')

        print()


p25 = pattern25();
p25.solution()

#Pattern26 - Part 1
class pattern26:
  def solution(self, n = None):
    if n == None:
      n = int(input('Enter the number of rows: '))

    size = 2 * n - 1

    for i in range(size):
      for j in range(size):
        if min(i, j, size - i - 1, size - j - 1) == 0:
          print(n, end = ' ')

        else:
          print(' ', end = ' ')

      print()


p26 = pattern26();
p26.solution()



#Pattern26 - Part 2
class pattern26:
  def solution(self, n = None):
    if n == None:
      n = int(input('Enter the number of rows: '))

    size = 2 * n - 1

    for i in range(size):
      for j in range(size):
        #printing the minimun distances of each element from the border
        min_dist = min(i, j, size - i - 1, size - j - 1)
        print(n - min_dist, end = ' ') #subtracting distance from the border valus gives us the number itself

      print()



p26 = pattern26();
p26.solution()