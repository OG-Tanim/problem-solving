# -*- coding: utf-8 -*-
"""strivers_recursion.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z4G2mvdmqscnJJX9gb0f4wsyv6aGF_8-
"""

class Problem1:
  def printNumbers(self, i, n = None):
    # while n == None:
    #   try:
    #     n = int(input("please enter a numebr = "))
    #     break
    #   except ValueError:
    #     print("invalid number")


    # base case
    if i > n:
      return

    print(i)

    #recursive call
    self.printNumbers(i + 1, n)

p1 = Problem1()
p1.printNumbers(1, 5)

""" Backtracking """

class Solution:
    def printNumbers(self, n):
        # Base case
        if n == 0:
            return

        # Recursive call before printing to ensure printing happens from the top of the stack
        self.printNumbers(n - 1)

        # Print current number
        print(n)
p2 = Solution()
p2.printNumbers(5)

class Solution:
    def printNumbers(self, n):
        # Base case
        if n == 0:
            return

        print(n)

        #recursive call
        self.printNumbers(n - 1)

obj = Solution()
obj.printNumbers(5)

class Problem1:
  def printNumbers(self, i, n):
    if i > n:
      return

    self.printNumbers(i + 1, n)
    print(i)

p1 = Problem1()
p1.printNumbers(1, 5)

#sum of N
class Solution:
  def sum(self, n):
    if n == 0:
      return 0
    return n + self.sum(n - 1)
obj = Solution()
obj.sum(5)

#sum of N
class Solution:
  def sum2(self, n, sum):
    if n == 0:
      print(sum)
      return

    self.sum2(n - 1, sum + n)

obj = Solution()
obj.sum2(5, 0)

#factorial of N
class Solution:
  def fact(self, n):
    if n == 0:
      return 1
    return n * self.fact(n - 1)
obj = Solution()
obj.fact(5)

#reverse Array
class Solution:
  def reverse(self, arr):
    a = len(arr)
    for i in range(a // 2):
      arr[i], arr[a - i - 1] = arr[a - i - 1], arr[i]
    return arr
obj = Solution()
obj.reverse([1,2,3,4,5])

#reverse Array
class Solution:
  def reverse2(self, arr, s, f):
    if s >= f:
      return
    arr[s], arr[f] = arr[f], arr[s]
    self.reverse2(arr, s + 1, f - 1)
    return arr
obj = Solution()
obj.reverse2([1,2,3,4,5], 0, 4)

#reverse Array
class Solution:
  def reverse3(self, arr, i = 0):
    if i >= len(arr) // 2:
      return
    arr[i], arr[len(arr) - 1 - i]= arr[len(arr) - 1 - i], arr[i]
    self.reverse3(arr, i + 1)
    return arr
obj = Solution()
obj.reverse3([1, 2, 3, 4, 5])

#check palindrome on a string
class Solution:
  def checkPalindrome(self, s, i = 0):
    if i >= len(s) // 2:
      return True
    elif s[i] != s[len(s) - 1 - i]:
      return False
    return self.checkPalindrome(s, i + 1)
obj = Solution()
obj.checkPalindrome("madama")

#String Palindrome Leetcode
class Solution:
    def isPalindrome(self, s: str) -> bool:
      ls = s.lower()
      print(ls)

      ns = "".join(char for char in ls if char.isalnum())
      print (ns)

      if ns == ns[::-1]:
        return True
      return False

obj = Solution()
obj.isPalindrome(" ")

#Fibonacchi
class Solution:
    def fib_iterative(self, n: int) -> int:
        if n <= 1:
            return n

        a, b = 0, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        return b


sol = Solution()
sol.fib_iterative(4)

class Solution:
    def fib_recursive(self, n: int) -> int:
        if n <= 1:
            return n
        n = self.fib_recursive(n - 1) + self.fib_recursive(n - 2)
        return n


sol = Solution()
sol.fib_recursive(6)